# Import core Flask modules
from flask import Flask, render_template, request, redirect, url_for, session, flash

# Import Bcrypt for password hashing (secure password storage)
from flask_bcrypt import Bcrypt

# Import Flask-Login tools for authentication & session management
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user


# Create the Flask application
app = Flask(__name__)

# Secret key is used to encrypt session data (required for login sessions & flash messages)
app.secret_key = "supersecretkey"

# Initialize bcrypt with the Flask app (used to hash passwords)
bcrypt = Bcrypt(app)

# Initialize login manager (handles user login sessions)
login_manager = LoginManager(app)

# If user tries to access protected page, redirect them to login page
login_manager.login_view = "login"


# Temporary in-memory "database"
# This dictionary stores usernames, hashed passwords, and roles
# In real systems, this would be replaced by a real database
users = {
    "admin": {
        "password": bcrypt.generate_password_hash("Admin123").decode("utf-8"),
        "role": "Admin"
    },
    "user": {
        "password": bcrypt.generate_password_hash("User123").decode("utf-8"),
        "role": "User"
    }
}


# User class required by Flask-Login
# UserMixin provides default implementations for authentication
class User(UserMixin):
    def __init__(self, username, role):
        self.id = username  # Flask-Login uses id to identify the user
        self.role = role    # Custom attribute to store user role


# This function tells Flask-Login how to reload a user from session
@login_manager.user_loader
def load_user(username):
    # If the username exists in our users dictionary
    if username in users:
        # Recreate the User object
        return User(username, users[username]["role"])
    return None


# Home route: redirect automatically to login page
@app.route("/")
def home():
    return redirect(url_for("login"))


# Registration page (GET = show form, POST = process registration)
@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        # Get form inputs
        username = request.form["username"]

        # Hash the password before saving (never store plain text passwords)
        password = bcrypt.generate_password_hash(request.form["password"]).decode("utf-8")

        # Default role is User unless specified
        role = request.form.get("role", "User")

        # Save new user to dictionary
        users[username] = {"password": password, "role": role}

        # Redirect to login after successful registration
        return redirect(url_for("login"))

    # If GET request, just show the registration page
    return render_template("register.html")


# Login route
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        # Get login credentials
        username = request.form["username"]
        password = request.form["password"]

        # Verify user exists AND password matches hashed version
        if username in users and bcrypt.check_password_hash(users[username]["password"], password):

            # Create user session object
            user = User(username, users[username]["role"])

            # Log the user in (creates session)
            login_user(user)

            # Save role in session for access control
            session["role"] = user.role

            # Redirect to dashboard after login
            return redirect(url_for("dashboard"))
        else:
            # If login fails, show error message
            flash("❌ Invalid username or password")

            # Keep username filled in form for convenience
            return render_template("login.html", username=username)

    # Show login page
    return render_template("login.html")


# Protected dashboard route (requires login)
@app.route("/dashboard")
@login_required  # Prevents access without authentication
def dashboard():

    # Show different message based on role
    if current_user.role == "Admin":
        return render_template(
            "dashboard.html",
            message="Welcome Admin!",
            role=current_user.role
        )

    return render_template(
        "dashboard.html",
        message="Welcome User!",
        role=current_user.role
    )


# Admin-only page
@app.route("/admin")
@login_required
def admin():

    # Check role from session
    # If not admin → deny access
    if session.get("role") != "Admin":
        return "Access Denied", 403

    return render_template("admin.html")


# Logout route
@app.route("/logout")
@login_required
def logout():
    # Clear login session
    logout_user()

    # Redirect back to login page
    return redirect(url_for("login"))


# Run the app in debug mode (auto reload + error messages)
if __name__ == "__main__":
    app.run(debug=True)
